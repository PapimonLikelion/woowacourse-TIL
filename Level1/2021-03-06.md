### 2021-03-06

## 클래스 vs 객체 vs 인스턴스
- 참고: https://gmlwjd9405.github.io/2018/09/17/class-object-instance.html

- __클래스(Class)__
    - 객체가 태어나는 곳
    - 필요에 따라 새로운 객체를 생성하고, 더는 사용하지 않을 때 객체를 파괴
    - 해당 클래스의 자식들이 어떤 모습 이여야하고, 어찌 행동해야 하는지 알고있다
    - 객체를 만들어 내기 위한 "설계도" or "틀"
    - 연관되어 있는 변수와 메서드의 집합
    - "설계도"
    
- __객체(Object)__
    - 소프트웨어 세계에 구현할 대상
    - 클래스에 선언된 모양 그대로 생성된 실체
    - "클래스의 인스턴스"라고 불림
    - 객체는 모든 인스턴스를 대표하는 포괄적인 의미를 갖는다
    - OOP 관점에서 "클래스의 타입으로 선언"되었을 때, 이를 "객체"라고 부른다
    - "설계도로 구현한 모든 대상"

- __인스턴스(Instance)__
    - 설계도를 바탕으로 SW에 구현된 "구체적인 실제"
    - 실체화된 인스턴스는 메모리에 할당됨
    - 인스턴스는 객체에 포함된다
    - 의미적으로 인스턴스는 어떤 원본(추상적 개념)으로부터 "생성된 복제본"을 의미

- __OOP 관점으로 정리__
    - 소스코드에 class로 작성된 코드는 "설계도"이며, 이는 <클래스>이다.
    - "클래스의 타입으로 새로운 변수가 선언"이 되었을때, 이는 <객체>가 된다. 
    - 객체가 "메모리에 할당"되어 실제 사용될 때, 이를 <인스턴스>라고 한다.

## 좋은 객체의 7가지 덕목
- 참고: https://codingnuri.com/seven-virtues-of-good-object/

1. 객체가 현실 세계에 존재한다
    - 객체는 생명체로, 자신만의 생명주기/행위/습관을 지닌 독립적인 개체다
    - 그저 자료구조와 함수의 집합이 아니란 것이다
    - 현실 세계의 피조물을 대표하는 것으로, 현실 세계의 대리자이다. 
    - 따라서, 현실세계에 존재하지 않는 다양한 객체는 리팩토링의 대상이 될 수 있다

2. 객체가 계약에 따라 동작한다
    - 자신의 특성이 아닌, 자신이 준수하는 계약에 의해 사용되어야 한다
    - 그 어떤 객체라도 "계약"에 명시된 일을 하도록 예상한다
        - Java에서는 "계약"을 interface로 표현한다
    - 좋은 객체 안에 담긴 모든 공용 메서드는 interface 내에 선언된, 상응하는 메서드들을 구현할 것
    
3. 객체가 고유하다
    - 좋은 객체는 언제나 고유하기 위해 무엇인가를 "캡슐화"한다
        - *캡슐화: 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다*
        - "캡슐화"할게 없다면, 즉 객체의 속성과 행위를 외부에 감출게 없다면, 다 똑같은 복제본을 가질 수 있다
    - 따라서, 정적(static) 메서드만이 담긴 util 클래스는 좋은 객체를 인스턴스화 할 수 없다
        - 또한, "클래스"라고 부를 수 없다
        - OOP 패러다임을 엉터리로 남용하는 것에 불과

4. 객체가 불변적이다
    - 좋은 객체는 자신이 캡슐화한 상태를 절대 변경하지 않음
        - 객체는 개체의 대표자로, 그것이 대표하는 것들을 절대 배신하지 않는다
    - 불변성을 보장하여 얻는 이점은...
        - 생성/테스트/사용에 용이
        - 언제나 thread-safe
        - temporal coupling을 피하게 해준다(?)
        - 캐싱에 용이
        - 방어적 복사를 안해도 된다
        - NULL 참조 방지
        - 실패 원자성을 보장
        
5. 객체의 클래스에 정적 멤버가 없다
    - 정적(static) 멤버는 "object-oriented"를 "class -oriented"로 변경
        - 클래스의 행위를 노출한다
        - 문제를 여러 부분으로 더 이상 분해할 수 없게 된다
    - Mocking이 불가능하다
    - thread-safe가 보장이 안된다

6. 객체의 이름이 직명을 나타내지 않는다
    - 이름은 그것이 무엇인지를 말해야 하지, 무슨일을 하는지 말해서는 안된다
        - 그것이 무엇인지를 나타내는 네이밍 (O)
            - ex) CardDeck
        - 그것이 무엇을 하는지 나타내는 네이밍 (X) 
            - ex) CardDistributor
    - "-er"로 끝나는 이름은 최대한 피하자

7. 객체의 클래스가 final이나 abstract다
    - final: 상속을 통해 확장할 수 없는 클래스
        - "나를 분해할 수 없어. 난 블랙박스야"
    - abstract: 인스턴스를 가질 수 없는 클래스
        - "난 이미 망가졌어. 날 먼저 고친 후에 사용해"
    - 나머지는 왜 안 되지?
        - 상속... 부모 클래스의 메서드 중 하나를 오버라이딩 하면서 로직이 전부 망가질 수 있음
        - 부모 클래스의 모든 메서드가, 자식 클래스의 새로운 버전을 사용함을 기억하자!
    
## 클래스와 인스턴스(심화) 수업 복습
