### 2021-02-19

## 자바 배경지식
- 참고1: https://aljjabaegi.tistory.com/387
- 참고2: https://www.youtube.com/watch?v=f0cAmTYo4tQ
- 참고3: https://www.youtube.com/watch?v=L19wXSpv5cs

- __Java 컴파일 과정__
    - Java 소스 코드(.java) ---Java Compiler(javac)--> Java 바이트 코드(.class)
    - Java 바이트 코드(.class) ---Class Loader--> JVM
        - 이제 JVM 안의 실행 엔진에 의해 기계어로 해석 후 메모리 상에 배치
        - 실행 엔진에는 Interpreter와 JIT Compiler가 있음
            - Interpreter: Java 바이트 코드 한 줄씩 실행, slow
            - JIT Compiler: 전체 바이트 코드 컴파일, slow but after cached fast

- __JVM 메모리 구조__
    - Stack Area
        - 클래스 내의 메서드에서 사용되는 정보들의 저장
        - 매개변수, 지역변수, 리턴값 등
    - Method Area
        - 클래스, 메서드, 인스턴스 변수, 클래스 변수, 상수 등 저장
    - Heap Area
        - New 명령어를 통해 생성한 인스턴스
        - 참조형 변수 정보들이 저장
        - GC의 대상
    - PC Register Area
        - Thread 별로 하나씩 생성된 JVM 명령의 주소값이 저장되는 곳
    - Native Method Stack Area
        - Java 외의 다른 언어의 호출 담당
        - C/C++을 호출하는 Stack 영역
    
- __JDK, JRE, JVM__
    - JDK > JRE > JVM 관계
        - JVM: OS 별로 다름. Bytecode를 검증하고 실행
        - JRE: JVM + 시스템 라이브러리들을 가지고 있음 *(scanner 등)*
        - JDK: JRE + 개발을 위한 도구 *(compiler, debugger 등)*

- __빌드__
    - 정의
        - 소스코드 파일을 여러 과정을 거쳐 컴퓨터에서 실행할 수 있는 독립 sw 가공물 *(jar, war)* 로 변환시키는 과정
    - 빌드 단계
        - 소스코드 컴파일
        - Test 코드 컴파일
        - Test 코드 실행
        - Test 코드 리포트 작성
        - 기타 추가 설정한 작업들 진행
        - 패키징 수행
        - 독립 sw 가공물 만들기
    - 빌드 자동화
        - 빌드가 수동이라면, 사람마다 다르게 빌드하고, 큰일 남
        - 소스코드의 빌드 과정을 자동으로 처리해주는 프로그램을 사용
        - 외부 라이브러리의 자동 추가/관리를 지원
        - ANT, Maven, Gradle이 존재
    - Maven
        - 빌드를 위해 xml으로 설정
        - 외부 라이브러리 관리 가능
        - ANT의 장황한 스크립트 해결
        - 하지만 xml의 태생적 한계에 부딪힘... 복잡
    - Gradle
        - 빌드를 위해 JVM 위에서 동작하는 Groovy 언어 사용
        - 외부 라이브러리 관리 가능
        - 유연한 빌드 스크립트 작성 가능
            - build.gradle에 dependencies를 추가해주자

## 자바 문자열

## 자바 JCF
- __정의__

- __List__

- __Stack__

- __Queue__

- __Set__

- __Map__

- __왜 Map은 Interface 상속 안받는가?__

## 자바 Generics

## 자바 Enum
- 참고: https://velog.io/@pop8682/Enum-27k067ns4a

- __정의__
    - 관련한 상수 Singleton 객체의 모음집
    - 컴파일 당시, 가능한 모든 값을 알고 있다면 Enum 활용을 고려해보자!

- __장점__
    - C/C++ 과는 다르게 Java Enum은 클래스 처럼 변수, 메서드, 생성자를 추가할 수 있다
    - 상태와 행위를 동시에 관리 가능하다!

- __특징__
    - 모든 Enum은 클래스를 통해 내부적으로 정의됨
    ``` Java
    public enum Operator {
        Plus("+"),      // public static final Operator Plus = new Operator("+") 와 동일
        Minus("-");     // public static final Operator Minus = new Operator("-") 와 동일
    } 
    ```
    - 모든 enum은 java.lang.Enum 클래스를 상속받음
        - 따라서 또다른 클래스를 enum에 상속할 수는 없다!
        
    - 생성자는 항상 private!
    
    - Setter는 쓰지말자
        - 컴파일 시에 필요한 상수를 모두 모았다는 전제하에 enum을 쓰는 것인데, 런타임에 수정할 구멍을 주면 의미가 없어서 그런 듯 하다.
        
- __제공 API__
    - values(): enum 안에 존재하는 모든 값 반환
    - ordinal(): enum 상수 인덱스 값 반환
    - valueOf(): 존재한다면 enum 상수의 스트링 값 반환
    
- __Calculator Enum 리팩토링__
``` Java
public enum Operator {
    PLUS("+") {
        @Override
        int calculate(Number a, Number b) {
            return a.add(b).toInt();
        }
    },
    MINUS("-") {
        @Override
        int calculate(Number a, Number b) {
            return a.sub(b).toInt();
        }
    },
    MULTIPLY("*") {
        @Override
        int calculate(Number a, Number b) {
            return a.multiply(b).toInt();
        }
    },
    DIVISION("/") {
        @Override
        int calculate(Number a, Number b) {
            return a.divide(b).toInt();
        }
    };

    private final String operator;
    private static final Map<String, Operator> OPERATOR_MAP = new HashMap<>();

    static {
        Arrays.stream(values())
                .forEach(operator -> OPERATOR_MAP.put(operator.operator, operator));
    }

    Operator(final String operator) {
        this.operator = operator;
    }

    public static Operator from(final String operator) {
        Operator requestedOperator = OPERATOR_MAP.get(operator);
        if (Objects.isNull(requestedOperator)) {
            throw new IllegalArgumentException();
        }
        return requestedOperator;
    }

    abstract int calculate(final Number a, final Number b);
}

public class Calculator {
    public Calculator() {
    }

    public int calculate(final String operator, final int a, final int b) {
        return Operator.from(operator).calculate(new Number(a), new Number(b));
    }
}
```