### 2021-02-24

## 자바 Exception
- 참고 1: https://cheese10yun.github.io/checked-exception/
- 참고 2: https://woowacourse.github.io/javable/post/2020-08-17-custom-exception/
- 참고 3: https://jamie95.tistory.com/entry/Java-StackTrace-%EC%9D%BD%EA%B8%B0

- __정의__
    - 프로그램이 실행 중 어떤 원인에 의해서 오작동을 하거나, 비정상적으로 종료되는 경우

- __역사__
    - 에러를 처리하는 두 가지 방법
        1. 반환값으로 실패를 전달해, 호출처에서 반환값을 체크하여 에러 처리 진행 *(C언어 등)*
            - 반환값 확인을 잊어버리면 말짱 도루묵
            - 2번이 더 발전된 방식으로 채택
        2. 호출처에서 호출하기 전에 에러 처리 코드를 등록, 실패 시 에러 처리 코드로 점프 *(현재 예외 처리 방식)*
    
    - 에러가 발생했을 떄 "점프할 장소를 사전에 등록"해두는 방법이 발전하여 예외 처리가 됨
        - 문제는 "짝을 이루는 처리"(lock/unlock, file open/close 등) 처리가 어려움
        - 함수가 어떤 예외 던질 지 확인이 힘듦
    
    - Java를 포함, 대부분의 예외 처리는 예외가 호출처로 전파됨
        - 다만, 호출처에서 부르는 모든 함수에 대한 예외 상황을 검토해야해 설계에 단점이 될 수도
        - 또한, 처리가 귀찮음. try/catch 쪽수 많아짐... 다른 언어에서는 잘 안쓰임

![exception](../image/exception_2021_02_24.PNG)
- __구조__
    - Error: 프로그램 코드에 의해서 수습될 수 없는 심각한 오류
    
    - Exception: 프로그램 코드에 의해서 수습될 수 있는 다소 미약한 오류
        - Exception 클래스들: 사용자의 실수와 같은 외적인 요인들에 의해 발생하는 예외
        - RuntimeException 클래스들: 프로그래머의 실수로 발생하는 예외
    
- __Checked Exception, Unchecked Exception__
    - Checked Exception(Exception 상속)
        - Compile Time Exception
        - 컴파일 시점에 Exception에 대한 처리(try/catch)가 없다면 "컴파일 에러"
        - Exception이 발생하는 메서드에서 "throws" 예약어를 활용해 Exception을 호출 메서드에게 필수 전달
        
    - Unchecked Exception(RuntimeException 상속)
        - Runtime Time Exception
        - 컴파일 시점에 Exception을 catch하는 지 확인 안 함.
        - Exception이 발생하는 메서드에서 "throws" 예약어를 활용해 Exception을 호출 메서드에게 필수 전달할 필요 X
            - 하지만 해도 무방
   
- __Exception vs RuntimeException__
    - Exception
        - 호출하는 메서드가 Exception을 활용해 무엇인가 의미 있는 작업을 할 수 있는 경우
    
    - RuntimeException
        - 호출하는 메서드가 Exception을 catch해 예외 상황 해결이 가능한 경우
        - 문제를 해결할 수 없는 경우

- __기존 Exception vs Custom Exception__
    - 기존 Exception
        1. 예외 메시지로도 충분히 의미 전달 가능
        2. 표준 예외를 통해 가독성 향상
        3. 일일히 예외 클래스 만들면, 커스텀 예외 너무 많아짐
            - 해당 패키지와 클래스 관리
            - 너무 많아진다면 메모리 문제까지!

    - Custom Exception
        1. 이름만으로도 정보 전달이 가능
        2. 상세한 예외 정보를 제공할 수 있음
        3. 예외에 대한 응집도 향상
            - 예외에 필요한 메시지
            - 전달할 정보의 데이터
            - 데이터 가공 메서드 등을 한 곳에서 관리 가능
        4. 예외 발생 후처리가 용이
            - 정확히 어디서 터진 에러인지 알기 쉽다
        5. 예외 생성 비용을 절감
            - 오히려 안쓰는 stackTrace() 메서드 오버라이드
                - fillInStackTrace() @Override
            - 단순하게 메시지만 넘겨준다면, 해당 예외를 캐싱해두는 것도 방법!

    - Brown's Opinion
        - 내 도메인에 한정된 exception은 직접 만들어도 좋다!

- __용어__
    - finally: 예외의 발생여부에 상관없이 실행되어야할 코드를 포함시킴
        - C++에는 finally가 없다! 접근하는 객체의 인스턴스를 만들어서 "소멸자"를 호출하는 방식으로 닫는다!
    
    - throw: 프로그래머가 고의로 예외를 발생시키는 것
    
    - stackTrace: Application이 시작된 시점부터 프로그램 내에서 현재 실행 위치까지의 메서드 호출 목록
        - 예외 발생시, JVM에 의해 자동 생성
    
- __문법__
    - 하나의 try 블럭 다음에는 여러 종류의 예외를 처리할 수 있도록 하나 이상의 catch 블럭을 둘 수 있다
        - BUT! 이 중 발생한 예외의 종류와 일치하는 단 "한 개"의 catch 블럭만 수행된다!
    
    - 예외가 발생하면, 발생한 예외에 해당하는 클래스의 인스턴스가 만들어짐
        - 첫 번째 catch 부터 차근 차근 내려가며 instanceof 연산자 통한 검사!
   
