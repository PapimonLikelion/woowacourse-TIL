### 2021-03-04

## 전략 패턴
- __디자인 패턴?__
    - (소프트웨어) 디자인 + (공통적으로 마주치는 문제를 해결하는 방법의) 패턴

- __전략 패턴?__
    - 객체가 할 수 있는 "행위"들 각각을 전략으로 만들어 놓고 사용하며, 동적으로 전략 수정이 가능한 패턴
        - 동일 계열의 알고리즘군을 정의
        - 각 알고리즘을 캡슐화
        - 이들을 상호교환이 가능하도록 함

- __추상 클래스로도 추상화 가능하지 않아?__
    - 추상 클래스를 통해, 상속받은 객체에서 메서드를 입맛에 맞게 정의 할 수 있다 but! 
        - 메서드 수정이 어려움
        - 새로운 기능의 추가가 어려움
    - 전략 패턴으로 해결하자!
    - 클래스가 수행해야 할 "행위"들을 인터페이스로 만들어두자
        - 바꾸고자 하는 전략의 메서드만 수정해주기
        - 새로운 기능에 대한 인터페이스를 만들어, 클래스에 추가해 주기

- __유연한 전략의 변경 가능__
    - setter를 통해 클래스 내의 전략을 쉽게 변경시킬 수 있다

## 상속보다는 조합
- __표현__
    - 상속: "IS-A"
    - 조합: "HAS-A"

- __상속__
    - 자식 클래스가 부모 클래스로 부터 무엇인가를 물려받는 것

- __상속의 장점__
    1. 코드의 재사용을 통해 중복을 줄인다
    2. 확장성이 증가한다
    3. 클래스 간의 계층적 관계를 구성함으로써 다형성을 구현할 수 있다
    4. 개발 시간이 단축된다

- __상속의 단점__
    1. 상위 클래스의 구현이 하위 클래스에게 노출되기에 캡슐화가 깨짐 (캡슐화란?)
    2. 자식 클래스가 부모 클래스에게 강하게 결합/의존
    3. 상위 클래스 로직 수정이 하위 클래스의 로직에 영향
    4. 상위 클래스가 수정되면, 하위 클래스가 오작동 할 수 있음
    
- __상속은 언제?__
    - 명확한 "IS-A" 관계에 있는 경우
    - 상위 클래스가 확장할 목적으로 설계되어 있고, 문서화도 잘된 경우
    - 상위 클래스와 하위 클래스 모두 같은 프로그래머가 통제하는 패키지 안이라면 괜찮다
    
- __조합__
    - 기존 클래스를 확장하는 대신, 새로운 클래스에 private 필드로 기존 클래스의 인스턴스를 생성해 참조하게 하는 설계
    
- __조합의 장점__
    1. 새로운 클래스는 기존 클래스의 내부 구현 방식에서 자유로움
    2. 메서드 호출로 동작하기에 캡슐화를 깨지 않음
    3. 상위 클래스에 의존하지 않기에 변화에 유연함

## 캡슐화?
- __정의__
    - 객체의 속성과 행위를 하나로 묶고, 실제 구현 내용 일부를 외부에 감추어 은닉한다
    - 데이터(변수) 및 함수(처리방법/메서드)를 논리적으로 하나로 묶어 놓은 것
    - 언어적 측면에서 접근 지정자를 두어 은닉의 정도를 기술하여 구현
        - private: 자기 클래스 내부의 메서드에서만 접근 허용
        - protected: 자기 클래스 내부 또는 상속받은 자식 클래스에서 접근 허용
        - public: 모든 접근을 허용

- __캡슐화 vs 은닉화__
    - 캡슐화: 책임을 완수하기 위해 필요한 변수와 함수를 묶어 놓은 것
    - 은닉화: 외부에 정해진 행동만을 제공하고, 정해진 행동을 하기 위한 세부 절차는 감추는 것 
